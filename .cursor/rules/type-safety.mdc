---
alwaysApply: true
applyTo: "**/*.ts,**/*.tsx,**/types/**/*.ts"
---

# Type Safety Rules

## **TUYỆT ĐỐI KHÔNG DÙNG `any`**

### **Alternatives cho `any`**

```typescript
// ❌ WRONG - Never do this
function processData(data: any): any {
  return data.someProperty
}

// ✅ CORRECT - Use proper typing
interface DataInput {
  someProperty: string
  otherProperty: number
}

function processData(data: DataInput): ProcessedData {
  return {
    processedValue: data.someProperty.toUpperCase()
  }
}

// ✅ CORRECT - Use unknown for truly unknown data
function handleUnknownData(data: unknown): string {
  if (typeof data === 'string') {
    return data
  }
  if (typeof data === 'object' && data !== null && 'toString' in data) {
    return String(data)
  }
  return 'Unknown data'
}
```

## **Backend Type Synchronization**

- Tham khảo backend types tại: `@shared/types/` và `@shared/dto/`
- Khi phát hiện type mismatch giữa FE/BE, báo cáo ngay với 3 options:
  - **Option A**: Cập nhật FE types theo BE + adapter
  - **Option B**: Đề xuất BE thay đổi + version hóa nếu breaking
  - **Option C**: Tạo transformation layer chấp nhận cả 2 format

### **Zod Schema Pattern**

```typescript
// Backend reference: @shared/types/product.types.ts
// Zod schema for runtime validation
export const ProductSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  priceInt: z.number().int().positive(),
  categoryId: z.string().uuid(),
  imageUrls: z.array(z.string().url()).default([]),
  isActive: z.boolean().default(true),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

// Type inference from schema
export type Product = z.infer<typeof ProductSchema>
```

## **Type Guards & Validation**

```typescript
// Type guard functions
export function isProduct(obj: unknown): obj is Product {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    typeof (obj as Record<string, unknown>).id === 'string' &&
    typeof (obj as Record<string, unknown>).name === 'string'
  )
}

// API response validation
export function validateApiResponse<T>(
  data: unknown, 
  schema: z.ZodSchema<T>
): T {
  try {
    return schema.parse(data)
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`API validation failed: ${error.message}`)
    }
    throw error
  }
}
```

## **Error Handling Types**

```typescript
// Result pattern for error handling
type Result<T, E = Error> = 
  | { success: true; data: T; error: null }
  | { success: false; data: null; error: E }

// API Error types
interface ApiError {
  statusCode: number
  message: string
  details?: unknown
}
```

## **Default Parameters Best Practices**

### **❌ TRÁNH: Default Parameter với Object Literal**

Default parameter với object literal `= {}` gây ra TypeScript strict mode false positives và unsafe member access errors:

```typescript
// ❌ WRONG - Gây false positives với TypeScript strict mode
async function listUsers(query: ListUsersQuery = {}): Promise<ListUsersResponse> {
  // TypeScript không thể infer type đúng, gây unsafe member access errors
  if (query.page !== undefined) {
    searchParams.set("page", query.page.toString());
  }
}

// ❌ WRONG - Cần nhiều eslint-disable comments
async function listUsers(query: ListUsersQuery = {}): Promise<ListUsersResponse> {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  if (query.page !== undefined) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-argument
    searchParams.set("page", query.page.toString());
  }
}
```

### **✅ ĐÚNG: Optional Parameter + Optional Chaining**

Sử dụng optional parameter `?` và optional chaining `?.` để tránh false positives:

```typescript
// ✅ CORRECT - Type-safe, không có false positives
async function listUsers(query?: ListUsersQuery): Promise<ListUsersResponse> {
  const searchParams = new URLSearchParams();
  
  if (query?.page !== undefined) {
    searchParams.set("page", query.page.toString());
  }
  if (query?.pageSize !== undefined) {
    searchParams.set("pageSize", query.pageSize.toString());
  }
  if (query?.search) {
    searchParams.set("search", query.search);
  }
  if (query?.role) {
    searchParams.set("role", query.role);
  }
  
  // ...
}
```

### **✅ ĐÚNG: Local Interface Definition (Nếu cần)**

Nếu vẫn gặp vấn đề với imported types, định nghĩa local interface:

```typescript
// ✅ CORRECT - Local interface cho better type inference
interface ListUsersParams {
  page?: number;
  pageSize?: number;
  search?: string;
  role?: UserRole;
}

async function listUsers(query?: ListUsersParams): Promise<ListUsersResponse> {
  // TypeScript infer type tốt hơn với local interface
  if (query?.page !== undefined) {
    searchParams.set("page", query.page.toString());
  }
}
```

### **✅ ĐÚNG: Destructuring với Default Values**

Cho function parameters phức tạp, dùng destructuring:

```typescript
// ✅ CORRECT - Destructuring với default values
function calculateCartTotals(
  items: CartItem[],
  options: {
    shippingCost?: number;
    taxRate?: number;
    discountAmount?: number;
  } = {},
): CartTotals {
  const {
    shippingCost = 30000,
    taxRate = 0.1,
    discountAmount = 0,
  } = options;
  
  // Type-safe usage
  const tax = subtotal * taxRate;
  // ...
}
```

### **Lý do:**

1. **TypeScript strict mode**: Default parameter `= {}` với object literal không được TypeScript infer đúng type
2. **ESLint false positives**: Gây ra `@typescript-eslint/no-unsafe-member-access` errors mặc dù code đúng
3. **Code cleanliness**: Tránh phải thêm nhiều `eslint-disable` comments
4. **Better type inference**: Optional parameter `?` cho TypeScript infer type tốt hơn

## **Component Props Type Safety**

```typescript
// ✅ Comprehensive prop types
interface ProductCardProps {
  product: Product
  variant?: 'default' | 'compact' | 'featured'
  onAddToCart?: (productId: string, quantity: number) => Promise<void>
  onFavorite?: (productId: string, isFavorite: boolean) => void
  className?: string
}

export const ProductCard = forwardRef<HTMLDivElement, ProductCardProps>(
  ({ product, variant = 'default', onAddToCart, className, ...props }, ref) => {
    // Type-safe implementation
  }
)
```
